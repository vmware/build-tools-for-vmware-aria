/*
 * #%L
 * vrops-package-maven-plugin
 * %%
 * Copyright (C) 2023 VMware
 * %%
 * Build Tools for VMware Aria
 * Copyright 2023 VMware, Inc.
 * 
 * This product is licensed to you under the BSD-2 license (the "License"). You may not use this product except in compliance with the BSD-2 License.  
 * 
 * This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file.
 * #L%
 */
package com.vmware.pscoe.maven.plugins;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;

import com.vmware.pscoe.iac.artifact.PackageStore;
import com.vmware.pscoe.iac.artifact.PackageStoreFactory;
import com.vmware.pscoe.iac.artifact.configuration.ConfigurationException;
import com.vmware.pscoe.iac.artifact.model.Package;
import com.vmware.pscoe.iac.artifact.model.PackageFactory;
import com.vmware.pscoe.iac.artifact.model.PackageType;

@Mojo(name = "push", defaultPhase = LifecyclePhase.PRE_INTEGRATION_TEST, requiresDependencyResolution = ResolutionScope.RUNTIME_PLUS_SYSTEM)
public class PushMojo extends AbstractIacMojo {
	@Parameter(defaultValue = "${project}")
	private MavenProject project;

	@Parameter(required = false, property = "dryrun", defaultValue = "false")
	private boolean dryrun;

	@Parameter(required = true, property = "includeDependencies", defaultValue = "true")
	private boolean includeDependencies;

	@Parameter(required = false, property = "files", defaultValue = "")
	private List<String> filesChanged;

	private static Package packageFromArtifact(Artifact artifact) {
		return PackageFactory.getInstance(PackageType.fromExtension(artifact.getType()), artifact.getFile(),
				new MavenArtifactPackageInfoProvider(artifact).getPackageName());
	}

	/**
	 * Import (push) all of the package artifacts into a remote vROps server.
	 *
	 * In general each project generates just one artifact, however it may have other artifacts as dependencies.
	 * If this maven plugin has been configured to include dependencies ({@link #includeDependencies} is true), then the target artifact, together with all dependencies
	 * including any transitive dependencies will be collected into a Collection object and passed as parameter to this method.
	 *
	 * In case {@link #includeDependencies} is false, then the Collection will contain just the target artifact (the one that is being generated by this maven project).
	 *
	 * We would loop through the whole collection of artifacts and import (push) each of them individially to the remote vROps server.
	 *
	 * @param allArtifacts The collection of artifacts to the imported (pushed) to the remote vROps server.
	 * @throws MojoExecutionException In case the maven plugin configuration is wrong or any other operation goes wrong.
	 */
	private void importArtifacts(Collection<Artifact> allArtifacts) throws MojoExecutionException {
		Map<String, List<Artifact>> artifactsByType = allArtifacts.stream().collect(Collectors.groupingBy(Artifact::getType));
		for (String type : artifactsByType.keySet()) {
			PackageType pkgType = PackageType.fromExtension(type);
			if (pkgType != null) {
				try {
					List<Package> packages = artifactsByType.get(type).stream().map(PushMojo::packageFromArtifact).collect(Collectors.toList());
					PackageStore<?> store = getConfigurationForType(PackageType.fromExtension(type))
							.flatMap(configuration -> Optional.of(PackageStoreFactory.getInstance(configuration)))
							.orElseThrow(() -> new ConfigurationException("Unable to find PackageStore based on configuration. "
									+ "Make sure there is configuration for type: " + pkgType.name()));

					boolean mergePackages = filesChanged.size() != 0; // it means that only a few files was selected to create the package
					this.getLog().info("Merge Package vrops PushMojo: " + mergePackages);
					store.importAllPackages(packages, dryrun, mergePackages);
				} catch (ConfigurationException e) {
					getLog().error(e);
					throw new MojoExecutionException(e, "Error processing configuration", "Error processing configuration");
				}
			}
		}

	}

	/**
	 * Implements the import/push use case to import package(s) into a remote vROps server.
	 * In all cases, the target artifact (the one that is generated by this maven project) will be imported/pushed. The parameter {@link #includeDependencies} will also
	 * be checked. If it is true, then additionally all dependencies including transitive dependencies will be imported/pushed to the remote vROps server.
	 * @throws MojoExecutionException In case there is failure in the maven plugin execution.
	 * @throws MojoFailureException In case there is failure in the Mojo (maven plugin).
	 */
	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		super.execute();

		final String artifactType = project.getArtifact().getType();

		final PackageType packageType = PackageType.fromExtension(artifactType);
		if (packageType == null) {
			getLog().warn(String.format("Skipping push because of unsupported artifact type '%s'", artifactType));
			return;
		}

		if (project.getArtifact().getFile() == null) {
			throw new MojoExecutionException("You need to have the package goal as well when pushing vRealize projects.");
		}

		LinkedList<Artifact> artifacts = new LinkedList<>();

		if (includeDependencies) {
			for (Object o : project.getArtifacts()) {
				artifacts.addLast((Artifact) o);
			}
		}
		artifacts.addLast(project.getArtifact());
		importArtifacts(artifacts);
	}

}
