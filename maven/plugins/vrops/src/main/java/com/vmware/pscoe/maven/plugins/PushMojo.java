package com.vmware.pscoe.maven.plugins;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;

import com.vmware.pscoe.iac.artifact.PackageStore;
import com.vmware.pscoe.iac.artifact.PackageStoreFactory;
import com.vmware.pscoe.iac.artifact.configuration.ConfigurationException;
import com.vmware.pscoe.iac.artifact.model.Package;
import com.vmware.pscoe.iac.artifact.model.PackageFactory;
import com.vmware.pscoe.iac.artifact.model.PackageType;

@Mojo(name = "push", defaultPhase = LifecyclePhase.PRE_INTEGRATION_TEST, requiresDependencyResolution = ResolutionScope.RUNTIME_PLUS_SYSTEM)
public class PushMojo extends AbstractIacMojo {
    @Parameter(defaultValue = "${project}")
    private MavenProject project;

    @Parameter(required = false, property = "dryrun", defaultValue = "false")
    private boolean dryrun;

    @Parameter(required = true, property = "includeDependencies", defaultValue = "true")
    private boolean includeDependencies;

	@Parameter(required = false, property = "files", defaultValue = "")
	private List<String> filesChanged;

    private static Package packageFromArtifact(Artifact artifact) {
        return PackageFactory.getInstance(PackageType.fromExtension(artifact.getType()), artifact.getFile(),
                new MavenArtifactPackageInfoProvider(artifact).getPackageName());
    }

    /**
     * Import (push) all of the package artifacts into a remote vROps server.
     *
     * In general each project generates just one artifact, however it may have other artifacts as dependencies.
     * If this maven plugin has been configured to include dependencies ({@link #includeDependencies} is true), then the target artifact, together with all dependencies
     * including any transitive dependencies will be collected into a Collection object and passed as parameter to this method.
     *
     * In case {@link #includeDependencies} is false, then the Collection will contain just the target artifact (the one that is being generated by this maven project).
     *
     * We would loop through the whole collection of artifacts and import (push) each of them individially to the remote vROps server.
     *
     * @param allArtifacts The collection of artifacts to the imported (pushed) to the remote vROps server.
     * @throws MojoExecutionException In case the maven plugin configuration is wrong or any other operation goes wrong.
     */
    private void importArtifacts(Collection<Artifact> allArtifacts) throws MojoExecutionException {
        Map<String, List<Artifact>> artifactsByType = allArtifacts.stream().collect(Collectors.groupingBy(Artifact::getType));
        for (String type : artifactsByType.keySet()) {
            PackageType pkgType = PackageType.fromExtension(type);
            if (pkgType != null) {
                try {
                    List<Package> packages = artifactsByType.get(type).stream().map(PushMojo::packageFromArtifact).collect(Collectors.toList());
                    PackageStore<?> store = getConfigurationForType(PackageType.fromExtension(type))
                            .flatMap(configuration -> Optional.of(PackageStoreFactory.getInstance(configuration)))
                            .orElseThrow(() -> new ConfigurationException("Unable to find PackageStore based on configuration. "
                                    + "Make sure there is configuration for type: " + pkgType.name()));

					boolean mergePackages = filesChanged.size() != 0; // it means that only a few files was selected to create the package
					this.getLog().info("Merge Package vrops PushMojo: " + mergePackages);
                    store.importAllPackages(packages, dryrun, mergePackages);
                } catch (ConfigurationException e) {
                    getLog().error(e);
                    throw new MojoExecutionException(e, "Error processing configuration", "Error processing configuration");
                }
            }
        }

    }

    /**
     * Implements the import/push use case to import package(s) into a remote vROps server.
     * In all cases, the target artifact (the one that is generated by this maven project) will be imported/pushed. The parameter {@link #includeDependencies} will also
     * be checked. If it is true, then additionally all dependencies including transitive dependencies will be imported/pushed to the remote vROps server.
     * @throws MojoExecutionException In case there is failure in the maven plugin execution.
     * @throws MojoFailureException In case there is failure in the Mojo (maven plugin).
     */
    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        super.execute();

        final String artifactType = project.getArtifact().getType();

        final PackageType packageType = PackageType.fromExtension(artifactType);
        if (packageType == null) {
            getLog().warn(String.format("Skipping push because of unsupported artifact type '%s'", artifactType));
            return;
        }

        if (project.getArtifact().getFile() == null) {
            throw new MojoExecutionException("You need to have the package goal as well when pushing vRealize projects.");
        }

        LinkedList<Artifact> artifacts = new LinkedList<>();

        if (includeDependencies) {
            for (Object o : project.getArtifacts()) {
                artifacts.addLast((Artifact) o);
            }
        }
        artifacts.addLast(project.getArtifact());
        importArtifacts(artifacts);
    }

}
