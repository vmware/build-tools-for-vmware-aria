/*-
 * #%L
 * vrotsc
 * %%
 * Copyright (C) 2023 - 2024 VMware
 * %%
 * Build Tools for VMware Aria
 * Copyright 2023 VMware, Inc.
 *
 * This product is licensed to you under the BSD-2 license (the "License"). You may not use this product except in compliance with the BSD-2 License.
 *
 * This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file.
 * #L%
 */
import { Decorator, MethodDeclaration, SourceFile } from "typescript";
import { StringBuilderClass } from "../../../../../utilities/stringBuilder";
import { CanvasItemPolymorphicBagForSwitch, WorkflowItemDescriptor, WorkflowItemType } from "../../../../decorators";
import { getDecoratorProps } from "../../../helpers/node";
import BaseItemDecoratorStrategy from "./base/baseItemDecoratorStrategy";
import { GraphNode } from "./helpers/graph";
import { InputOutputBindings } from "./helpers/presentation";
import { WrapperSourceFilePrinter } from "./helpers/sourceFile";

/**
 * Responsible for printing out switch items in workflow definitions.
 * 
 * Switch elements support multiple conditions and targets different items based on the conditions.
 * This strategy handles the transformation of TypeScript switch decorators into workflow XML elements
 * with conditional logic, script generation, and proper binding configuration.
 *
 * @example
 * Generated XML structure:
 * ```xml
 * <workflow-item name="item4" type="switch">
 *   <display-name><![CDATA[Switch]]></display-name>
 *   <script encoded="false"><![CDATA[// Generated by the system, cannot be edited
 *     if (asd === 1) {
 *       return "item5";
 *     } else if (asd === 2) {
 *       return "item6";
 *     } else if (true) {
 *       return "item0";
 *     }
 *   ]]></script>
 *   <in-binding>
 *     <bind name="asd" type="number" export-name="asd"/>
 *   </in-binding>
 *   <out-binding/>
 *   <condition name="asd" type="number" comparator="0" label="item5">1</condition>
 *   <condition name="asd" type="number" comparator="0" label="item6">2</condition>
 *   <condition name="" type="boolean" comparator="6" label="item0"/>
 *   <description><![CDATA[Basic switch activity based on a workflow attribute or parameter.]]></description>
 *   <position y="60.0" x="500.0"/>
 * </workflow-item>
 * ```
 * 
 * @extends BaseItemDecoratorStrategy
 */
export default class SwitchItemDecoratorStrategy extends BaseItemDecoratorStrategy {

	/**
	 * Maps user-friendly comparator strings to their numeric equivalents.
	 * This provides a more intuitive API for developers while maintaining compatibility
	 * with the underlying workflow engine.
	 */
	private static readonly COMPARATOR_MAP: Record<string, string> = {
		"===": "0",  // Equal to
		"==": "0",   // Equal to (loose equality, maps to strict for consistency)
		"!==": "1",  // Not equal to
		"!=": "1",   // Not equal to (loose inequality, maps to strict for consistency)
		">": "2",    // Greater than
		">=": "3",   // Greater than or equal to
		"<": "4",    // Less than
		"<=": "5",   // Less than or equal to
		"true": "6", // Always true (default case)
		"false": "7" // Always false
	};

	/**
	 * Creates a new instance of SwitchItemDecoratorStrategy.
	 * Initializes the source file printer for wrapper function handling.
	 */
	constructor() {
		super();
		this.sourceFilePrinter = new WrapperSourceFilePrinter();
	}

	/**
	 * Gets the workflow item type that this strategy handles.
	 * 
	 * @returns {WorkflowItemType} The switch workflow item type
	 */
	public getDecoratorType(): WorkflowItemType {
		return WorkflowItemType.Switch;
	}

	/**
	 * Gets the canvas type identifier for switch items.
	 * 
	 * @returns {string} The canvas type string "switch"
	 */
	public getCanvasType(): string {
		return "switch";
	}

	/**
	 * Registers and processes item arguments from the decorator node.
	 * 
	 * Processes the following decorator properties:
	 * - `target`: The target item for the switch
	 * - `exception`: Exception handling configuration
	 * - `cases`: Array of case conditions and their targets
	 * - `defaultTarget`: Default target when no cases match
	 * 
	 * @param {WorkflowItemDescriptor} itemInfo - The workflow item descriptor to populate
	 * @param {Decorator} decoratorNode - The TypeScript decorator node containing the arguments
	 * @throws {Error} When an unsupported item attribute is encountered
	 */
	public registerItemArguments(itemInfo: WorkflowItemDescriptor, decoratorNode: Decorator): void {
		const decoratorProperties = getDecoratorProps(decoratorNode);
		if (!decoratorProperties?.length) {
			return;
		}

		// Initialize the polymorphic bag for switch if not present
		if (!itemInfo.canvasItemPolymorphicBag) {
			itemInfo.canvasItemPolymorphicBag = { cases: [] };
		}

		decoratorProperties.forEach((propTuple) => {
			const [propName, propValue] = propTuple;
			switch (propName) {
				case "target":
					itemInfo.target = propValue;
					break;

				case "exception":
					itemInfo.canvasItemPolymorphicBag.exception = propValue;
					break;

				case "cases":
					if (Array.isArray(propValue)) {
						itemInfo.canvasItemPolymorphicBag.cases = propValue;
					}
					break;

				case "defaultTarget":
					itemInfo.canvasItemPolymorphicBag.defaultTarget = propValue;
					break;

				default:
					throw new Error(`Item attribute '${propName}' is not supported for ${this.getDecoratorType()} item`);
			}
		});
	}

	/**
	 * Creates a graph node representation for the switch item with all its target connections.
	 * 
	 * The graph node includes connections to all case targets and the default target if specified.
	 * This is used for workflow graph analysis and visualization.
	 * 
	 * @param {WorkflowItemDescriptor} itemInfo - The workflow item descriptor
	 * @param {number} pos - The position of the item in the workflow
	 * @returns {GraphNode} The graph node with target connections configured
	 * @see BaseItemDecoratorStrategy.getGraphNode
	 */
	public getGraphNode(itemInfo: WorkflowItemDescriptor, pos: number): GraphNode {
		const node: GraphNode = super.getGraphNode(itemInfo, pos, [0, -10]);
		const switchBag = itemInfo.canvasItemPolymorphicBag as CanvasItemPolymorphicBagForSwitch;

		// Add all case targets
		if (switchBag.cases) {
			switchBag.cases.forEach(caseItem => {
				if (caseItem.target) {
					node.targets.push(super.findTargetItem(caseItem.target, pos, itemInfo));
				}
			});
		}

		// Add default target if specified
		if (switchBag.defaultTarget) {
			node.targets.push(super.findTargetItem(switchBag.defaultTarget, pos, itemInfo));
		}

		return node;
	}

	/**
	 * Prints the source file content for the switch item.
	 * 
	 * Delegates to the source file printer to handle wrapper function processing
	 * and generate the appropriate source code representation.
	 * 
	 * @param {MethodDeclaration} methodNode - The TypeScript method declaration node
	 * @param {SourceFile} sourceFile - The TypeScript source file
	 * @param {WorkflowItemDescriptor} itemInfo - The workflow item descriptor
	 * @returns {string} The processed source file content
	 */
	public printSourceFile(methodNode: MethodDeclaration, sourceFile: SourceFile, itemInfo: WorkflowItemDescriptor): string {
		return this.sourceFilePrinter.printSourceFile(methodNode, sourceFile, itemInfo);
	}

	/**
	 * Prints out the complete XML representation of the switch item.
	 *
	 * The switch item generates conditional logic and includes condition elements
	 * for each case defined in the switch. The generated XML includes:
	 * - Display name and description
	 * - Generated script with conditional logic
	 * - Input/output parameter bindings
	 * - Condition elements for each case
	 * - Position information for UI display
	 *
	 * @param {WorkflowItemDescriptor} itemInfo - The item descriptor containing switch configuration
	 * @param {number} pos - The position of the item in the workflow (used for item naming)
	 * @param {number} x - X-axis position for UI display
	 * @param {number} y - Y-axis position for UI display
	 * @returns {string} The complete XML representation of the switch item
	 */
	public printItem(itemInfo: WorkflowItemDescriptor, pos: number, x: number, y: number): string {
		const stringBuilder = new StringBuilderClass("", "");
		const switchBag = itemInfo.canvasItemPolymorphicBag as CanvasItemPolymorphicBagForSwitch;

		// Generate the switch script
		const switchScript = this.generateSwitchScript(itemInfo, switchBag, pos);

		stringBuilder.append(`<workflow-item name="item${pos}" type="${this.getCanvasType()}">`);

		stringBuilder.indent();
		stringBuilder.append(`<display-name><![CDATA[${itemInfo.name}]]></display-name>`).appendLine();
		stringBuilder.append(`<script encoded="false"><![CDATA[${switchScript}]]></script>`).appendLine();
		stringBuilder.appendContent(super.buildParameterBindings(itemInfo, InputOutputBindings.IN_BINDINGS));
		stringBuilder.appendContent(super.buildParameterBindings(itemInfo, InputOutputBindings.OUT_BINDINGS));

		// Add condition elements
		this.addConditionElements(stringBuilder, switchBag, pos, itemInfo);

		stringBuilder.append(`<description><![CDATA[Basic switch activity based on a workflow attribute or parameter.]]></description>`).appendLine();
		stringBuilder.append(super.formatItemPosition([x, y])).appendLine();
		stringBuilder.unindent();
		stringBuilder.append(`</workflow-item>`).appendLine();

		return stringBuilder.toString();
	}

	/**
	 * Generates the JavaScript switch script logic for the workflow item.
	 * 
	 * Creates a conditional if-else chain that evaluates each case condition
	 * and returns the appropriate target item name. The script is marked as
	 * system-generated and non-editable.
	 * 
	 * @private
	 * @param {WorkflowItemDescriptor} itemInfo - The workflow item descriptor
	 * @param {CanvasItemPolymorphicBagForSwitch} switchBag - The switch configuration bag
	 * @param {number} pos - The position of the item in the workflow
	 * @returns {string} The generated JavaScript switch script
	 */
	private generateSwitchScript(itemInfo: WorkflowItemDescriptor, switchBag: CanvasItemPolymorphicBagForSwitch, pos: number): string {
		const lines = ["// Generated by the system, cannot be edited"];
		
		if (switchBag.cases && switchBag.cases.length > 0) {
			switchBag.cases.forEach((caseItem, index) => {
				const targetItem = super.findTargetItem(caseItem.target, pos, itemInfo);
				const condition = this.formatConditionForScript(caseItem);
				
				if (index === 0) {
					lines.push(`if (${condition}) {`);
				} else {
					lines.push(`} else if (${condition}) {`);
				}
				lines.push(`  return "${targetItem}";`);
			});
		}

		// Add default case
		if (switchBag.defaultTarget) {
			const defaultTargetItem = super.findTargetItem(switchBag.defaultTarget, pos, itemInfo);
			lines.push(`} else if (true) {`);
			lines.push(`  return "${defaultTargetItem}";`);
		}

		if (lines.length > 1) {
			lines.push("}");
		}

		return lines.join("\n");
	}

	/**
	 * Formats a case condition for use in the generated JavaScript script.
	 * 
	 * Handles different condition types (string, number, boolean) and generates
	 * appropriate comparison expressions. String conditions are wrapped in quotes,
	 * while numbers and booleans are used directly.
	 * 
	 * @private
	 * @param {any} caseItem - The case item containing variable and condition properties
	 * @param {string} caseItem.variable - The variable name to compare (defaults to "value")
	 * @param {any} caseItem.condition - The condition value to compare against
	 * @returns {string} The formatted condition expression for the script
	 */
	private formatConditionForScript(caseItem: any): string {
		const variable = caseItem.variable || "value";
		const condition = caseItem.condition;
		
		if (typeof condition === "string") {
			return `${variable} === "${condition}"`;
		} else if (typeof condition === "number") {
			return `${variable} === ${condition}`;
		} else if (typeof condition === "boolean") {
			return condition.toString();
		}
		
		return `${variable} === ${JSON.stringify(condition)}`;
	}

	/**
	 * Adds XML condition elements to the workflow item definition.
	 * 
	 * Creates `<condition>` XML elements for each case in the switch, including:
	 * - Variable name and type information
	 * - Comparator type (mapped from user-friendly strings to numeric codes)
	 * - Target label for workflow navigation
	 * - Condition value
	 * 
	 * @private
	 * @param {StringBuilderClass} stringBuilder - The string builder to append XML to
	 * @param {CanvasItemPolymorphicBagForSwitch} switchBag - The switch configuration bag
	 * @param {number} pos - The position of the item in the workflow
	 * @param {WorkflowItemDescriptor} itemInfo - The workflow item descriptor
	 */
	private addConditionElements(stringBuilder: StringBuilderClass, switchBag: CanvasItemPolymorphicBagForSwitch, pos: number, itemInfo: WorkflowItemDescriptor): void {
		if (switchBag.cases) {
			switchBag.cases.forEach(caseItem => {
				const targetItem = super.findTargetItem(caseItem.target, pos, itemInfo);
				const variableName = caseItem.variable || "";
				const type = caseItem.type || this.inferTypeFromCondition(caseItem.condition);
				const comparator = this.mapComparatorToNumeric(caseItem.comparator);
				
				stringBuilder.append(`<condition name="${variableName}" type="${type}" comparator="${comparator}" label="${targetItem}">`);
				
				if (caseItem.condition !== undefined && caseItem.condition !== null) {
					stringBuilder.append(caseItem.condition.toString());
				}
				
				stringBuilder.append(`</condition>`).appendLine();
			});
		}

		// Add default condition if present
		if (switchBag.defaultTarget) {
			const defaultTargetItem = super.findTargetItem(switchBag.defaultTarget, pos, itemInfo);
			stringBuilder.append(`<condition name="" type="boolean" comparator="6" label="${defaultTargetItem}"/>`).appendLine();
		}
	}

	/**
	 * Infers the data type from a condition value for XML type attributes.
	 * 
	 * Analyzes the JavaScript type of the condition value and maps it to
	 * the appropriate XML type string for workflow condition elements.
	 * 
	 * @private
	 * @param {any} condition - The condition value to analyze
	 * @returns {string} The inferred type ("string", "number", "boolean", defaults to "string")
	 */
	private inferTypeFromCondition(condition: any): string {
		if (typeof condition === "string") {
			return "string";
		} else if (typeof condition === "number") {
			return "number";
		} else if (typeof condition === "boolean") {
			return "boolean";
		}
		return "string";
	}

	/**
	 * Maps user-friendly comparator strings to their numeric equivalents.
	 * 
	 * Converts intuitive comparator strings (like "===", ">", "<=") to the numeric
	 * codes expected by the workflow engine. Falls back to "0" (equals) for 
	 * unrecognized comparators or backward compatibility with existing numeric codes.
	 * 
	 * @private
	 * @param {string | undefined} comparator - The user-friendly comparator string or numeric code
	 * @returns {string} The numeric comparator code for the workflow engine
	 */
	private mapComparatorToNumeric(comparator: string | undefined): string {
		if (!comparator) {
			return "0"; // Default to equals
		}

		// If it's already a numeric code, return as-is for backward compatibility
		if (/^\d+$/.test(comparator)) {
			return comparator;
		}

		// Map user-friendly comparator to numeric code
		const numericCode = SwitchItemDecoratorStrategy.COMPARATOR_MAP[comparator];
		if (numericCode !== undefined) {
			return numericCode;
		}

		// Default to equals for unrecognized comparators
		return "0";
	}
}