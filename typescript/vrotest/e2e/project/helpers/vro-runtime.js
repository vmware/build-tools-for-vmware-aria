'use strict'; const t = require('fs'); const e = require('constants'); const r = require('stream'); const o = require('util'); const n = require('assert'); const i = require('path'); const c = require('crypto'); function s (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const a = s(t); const u = s(e); const l = s(r); const p = s(o); const f = s(n); const d = s(i); const h = s(c); const w = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; const m = {}; const y = { fromCallback: function (t) { return Object.defineProperty(function (...e) { if (typeof e[e.length - 1] !== 'function') return new Promise((r, o) => { t.call(this, ...e, (t, e) => t != null ? o(t) : r(e)) }); t.apply(this, e) }, 'name', { value: t.name }) }, fromPromise: function (t) { return Object.defineProperty(function (...e) { const r = e[e.length - 1]; if (typeof r !== 'function') return t.apply(this, e); t.apply(this, e.slice(0, -1)).then(t => r(null, t), r) }, 'name', { value: t.name }) } }; const S = u.default; const E = process.cwd; let g = null; const N = process.env.GRACEFUL_FS_PLATFORM || process.platform; process.cwd = function () { return g || (g = E.call(process)), g }; try { process.cwd() } catch (t) {} if (typeof process.chdir === 'function') { const v = process.chdir; process.chdir = function (t) { g = null, v.call(process, t) }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, v) } const b = function (t) { S.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && (function (t) { t.lchmod = function (e, r, o) { t.open(e, S.O_WRONLY | S.O_SYMLINK, r, function (e, n) { e ? o && o(e) : t.fchmod(n, r, function (e) { t.close(n, function (t) { o && o(e || t) }) }) }) }, t.lchmodSync = function (e, r) { let o; const n = t.openSync(e, S.O_WRONLY | S.O_SYMLINK, r); let i = !0; try { o = t.fchmodSync(n, r), i = !1 } finally { if (i) try { t.closeSync(n) } catch (t) {} else t.closeSync(n) } return o } }(t)); t.lutimes || (function (t) { S.hasOwnProperty('O_SYMLINK') ? (t.lutimes = function (e, r, o, n) { t.open(e, S.O_SYMLINK, function (e, i) { e ? n && n(e) : t.futimes(i, r, o, function (e) { t.close(i, function (t) { n && n(e || t) }) }) }) }, t.lutimesSync = function (e, r, o) { let n; const i = t.openSync(e, S.O_SYMLINK); let c = !0; try { n = t.futimesSync(i, r, o), c = !1 } finally { if (c) try { t.closeSync(i) } catch (t) {} else t.closeSync(i) } return n }) : (t.lutimes = function (t, e, r, o) { o && process.nextTick(o) }, t.lutimesSync = function () {}) }(t)); t.chown = n(t.chown), t.fchown = n(t.fchown), t.lchown = n(t.lchown), t.chmod = r(t.chmod), t.fchmod = r(t.fchmod), t.lchmod = r(t.lchmod), t.chownSync = i(t.chownSync), t.fchownSync = i(t.fchownSync), t.lchownSync = i(t.lchownSync), t.chmodSync = o(t.chmodSync), t.fchmodSync = o(t.fchmodSync), t.lchmodSync = o(t.lchmodSync), t.stat = c(t.stat), t.fstat = c(t.fstat), t.lstat = c(t.lstat), t.statSync = s(t.statSync), t.fstatSync = s(t.fstatSync), t.lstatSync = s(t.lstatSync), t.lchmod || (t.lchmod = function (t, e, r) { r && process.nextTick(r) }, t.lchmodSync = function () {}); t.lchown || (t.lchown = function (t, e, r, o) { o && process.nextTick(o) }, t.lchownSync = function () {}); N === 'win32' && (t.rename = (e = t.rename, function (r, o, n) { const i = Date.now(); let c = 0; e(r, o, function s (a) { if (a && (a.code === 'EACCES' || a.code === 'EPERM') && Date.now() - i < 6e4) return setTimeout(function () { t.stat(o, function (t, i) { t && t.code === 'ENOENT' ? e(r, o, s) : n(a) }) }, c), void (c < 100 && (c += 10)); n && n(a) }) })); let e; function r (e) { return e ? function (r, o, n) { return e.call(t, r, o, function (t) { a(t) && (t = null), n && n.apply(this, arguments) }) } : e } function o (e) { return e ? function (r, o) { try { return e.call(t, r, o) } catch (t) { if (!a(t)) throw t } } : e } function n (e) { return e ? function (r, o, n, i) { return e.call(t, r, o, n, function (t) { a(t) && (t = null), i && i.apply(this, arguments) }) } : e } function i (e) { return e ? function (r, o, n) { try { return e.call(t, r, o, n) } catch (t) { if (!a(t)) throw t } } : e } function c (e) { return e ? function (r, o, n) { function i (t, e) { e && (e.uid < 0 && (e.uid += 4294967296), e.gid < 0 && (e.gid += 4294967296)), n && n.apply(this, arguments) } return typeof o === 'function' && (n = o, o = null), o ? e.call(t, r, o, i) : e.call(t, r, i) } : e } function s (e) { return e ? function (r, o) { const n = o ? e.call(t, r, o) : e.call(t, r); return n && (n.uid < 0 && (n.uid += 4294967296), n.gid < 0 && (n.gid += 4294967296)), n } : e } function a (t) { return !t || (t.code === 'ENOSYS' || !(process.getuid && process.getuid() === 0 || t.code !== 'EINVAL' && t.code !== 'EPERM')) }t.read = (function (e) { function r (r, o, n, i, c, s) { let a; if (s && typeof s === 'function') { let u = 0; a = function (l, p, f) { if (l && l.code === 'EAGAIN' && u < 10) return u++, e.call(t, r, o, n, i, c, a); s.apply(this, arguments) } } return e.call(t, r, o, n, i, c, a) } return Object.setPrototypeOf && Object.setPrototypeOf(r, e), r }(t.read)), t.readSync = (u = t.readSync, function (e, r, o, n, i) { for (let c = 0; ;) try { return u.call(t, e, r, o, n, i) } catch (t) { if (t.code === 'EAGAIN' && c < 10) { c++; continue } throw t } }); let u }; const k = l.default.Stream; const C = function (t) { return { ReadStream: function e (r, o) { if (!(this instanceof e)) return new e(r, o); k.call(this); const n = this; this.path = r, this.fd = null, this.readable = !0, this.paused = !1, this.flags = 'r', this.mode = 438, this.bufferSize = 65536, o = o || {}; for (let i = Object.keys(o), c = 0, s = i.length; c < s; c++) { const a = i[c]; this[a] = o[a] } this.encoding && this.setEncoding(this.encoding); if (void 0 !== this.start) { if (typeof this.start !== 'number') throw TypeError('start must be a Number'); if (void 0 === this.end) this.end = 1 / 0; else if (typeof this.end !== 'number') throw TypeError('end must be a Number'); if (this.start > this.end) throw new Error('start must be <= end'); this.pos = this.start } if (this.fd !== null) return void process.nextTick(function () { n._read() }); t.open(this.path, this.flags, this.mode, function (t, e) { if (t) return n.emit('error', t), void (n.readable = !1); n.fd = e, n.emit('open', e), n._read() }) }, WriteStream: function e (r, o) { if (!(this instanceof e)) return new e(r, o); k.call(this), this.path = r, this.fd = null, this.writable = !0, this.flags = 'w', this.encoding = 'binary', this.mode = 438, this.bytesWritten = 0, o = o || {}; for (let n = Object.keys(o), i = 0, c = n.length; i < c; i++) { const s = n[i]; this[s] = o[s] } if (void 0 !== this.start) { if (typeof this.start !== 'number') throw TypeError('start must be a Number'); if (this.start < 0) throw new Error('start must be >= zero'); this.pos = this.start } this.busy = !1, this._queue = [], this.fd === null && (this._open = t.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush()) } } }; const P = function (t) { if (t === null || typeof t !== 'object') return t; if (t instanceof Object) var e = { __proto__: F(t) }; else e = Object.create(null); return Object.getOwnPropertyNames(t).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)) }), e }; var F = Object.getPrototypeOf || function (t) { return t.__proto__ }; let O; let T; const D = a.default; const I = b; const A = C; const x = P; const L = p.default; function j (t, e) { Object.defineProperty(t, O, { get: function () { return e } }) } typeof Symbol === 'function' && typeof Symbol.for === 'function' ? (O = Symbol.for('graceful-fs.queue'), T = Symbol.for('graceful-fs.previous')) : (O = '___graceful-fs.queue', T = '___graceful-fs.previous'); let W = function () {}; if (L.debuglog ? W = L.debuglog('gfs4') : /\bgfs4\b/i.test(process.env.NODE_DEBUG || '') && (W = function () { let t = L.format.apply(L, arguments); t = 'GFS4: ' + t.split(/\n/).join('\nGFS4: '), console.error(t) }), !D[O]) { const R = w[O] || []; j(D, R), D.close = (function (t) { function e (e, r) { return t.call(D, e, function (t) { t || J(), typeof r === 'function' && r.apply(this, arguments) }) } return Object.defineProperty(e, T, { value: t }), e }(D.close)), D.closeSync = (function (t) { function e (e) { t.apply(D, arguments), J() } return Object.defineProperty(e, T, { value: t }), e }(D.closeSync)), /\bgfs4\b/i.test(process.env.NODE_DEBUG || '') && process.on('exit', function () { W(D[O]), f.default.equal(D[O].length, 0) }) }w[O] || j(w, D[O]); let _; let $ = M(x(D)); function M (t) { I(t), t.gracefulify = M, t.createReadStream = function (e, r) { return new t.ReadStream(e, r) }, t.createWriteStream = function (e, r) { return new t.WriteStream(e, r) }; const e = t.readFile; t.readFile = function (t, r, o) { typeof r === 'function' && (o = r, r = null); return (function t (r, o, n, i) { return e(r, o, function (e) { !e || e.code !== 'EMFILE' && e.code !== 'ENFILE' ? typeof n === 'function' && n.apply(this, arguments) : U([t, [r, o, n], e, i || Date.now(), Date.now()]) }) }(t, r, o)) }; const r = t.writeFile; t.writeFile = function (t, e, o, n) { typeof o === 'function' && (n = o, o = null); return (function t (e, o, n, i, c) { return r(e, o, n, function (r) { !r || r.code !== 'EMFILE' && r.code !== 'ENFILE' ? typeof i === 'function' && i.apply(this, arguments) : U([t, [e, o, n, i], r, c || Date.now(), Date.now()]) }) }(t, e, o, n)) }; const o = t.appendFile; o && (t.appendFile = function (t, e, r, n) { typeof r === 'function' && (n = r, r = null); return (function t (e, r, n, i, c) { return o(e, r, n, function (o) { !o || o.code !== 'EMFILE' && o.code !== 'ENFILE' ? typeof i === 'function' && i.apply(this, arguments) : U([t, [e, r, n, i], o, c || Date.now(), Date.now()]) }) }(t, e, r, n)) }); const n = t.copyFile; n && (t.copyFile = function (t, e, r, o) { typeof r === 'function' && (o = r, r = 0); return (function t (e, r, o, i, c) { return n(e, r, o, function (n) { !n || n.code !== 'EMFILE' && n.code !== 'ENFILE' ? typeof i === 'function' && i.apply(this, arguments) : U([t, [e, r, o, i], n, c || Date.now(), Date.now()]) }) }(t, e, r, o)) }); const i = t.readdir; if (t.readdir = function (t, e, r) { typeof e === 'function' && (r = e, e = null); return (function t (e, r, o, n) { return i(e, r, function (i, c) { !i || i.code !== 'EMFILE' && i.code !== 'ENFILE' ? (c && c.sort && c.sort(), typeof o === 'function' && o.call(this, i, c)) : U([t, [e, r, o], i, n || Date.now(), Date.now()]) }) }(t, e, r)) }, process.version.substr(0, 4) === 'v0.8') { const c = A(t); p = c.ReadStream, f = c.WriteStream } const s = t.ReadStream; s && (p.prototype = Object.create(s.prototype), p.prototype.open = function () { const t = this; h(t.path, t.flags, t.mode, function (e, r) { e ? (t.autoClose && t.destroy(), t.emit('error', e)) : (t.fd = r, t.emit('open', r), t.read()) }) }); const a = t.WriteStream; a && (f.prototype = Object.create(a.prototype), f.prototype.open = function () { const t = this; h(t.path, t.flags, t.mode, function (e, r) { e ? (t.destroy(), t.emit('error', e)) : (t.fd = r, t.emit('open', r)) }) }), Object.defineProperty(t, 'ReadStream', { get: function () { return p }, set: function (t) { p = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, 'WriteStream', { get: function () { return f }, set: function (t) { f = t }, enumerable: !0, configurable: !0 }); let u = p; Object.defineProperty(t, 'FileReadStream', { get: function () { return u }, set: function (t) { u = t }, enumerable: !0, configurable: !0 }); let l = f; function p (t, e) { return this instanceof p ? (s.apply(this, arguments), this) : p.apply(Object.create(p.prototype), arguments) } function f (t, e) { return this instanceof f ? (a.apply(this, arguments), this) : f.apply(Object.create(f.prototype), arguments) }Object.defineProperty(t, 'FileWriteStream', { get: function () { return l }, set: function (t) { l = t }, enumerable: !0, configurable: !0 }); const d = t.open; function h (t, e, r, o) { return typeof r === 'function' && (o = r, r = null), (function t (e, r, o, n, i) { return d(e, r, o, function (c, s) { !c || c.code !== 'EMFILE' && c.code !== 'ENFILE' ? typeof n === 'function' && n.apply(this, arguments) : U([t, [e, r, o, n], c, i || Date.now(), Date.now()]) }) }(t, e, r, o)) } return t.open = h, t } function U (t) { W('ENQUEUE', t[0].name, t[1]), D[O].push(t), G() } function J () { for (let t = Date.now(), e = 0; e < D[O].length; ++e)D[O][e].length > 2 && (D[O][e][3] = t, D[O][e][4] = t); G() } function G () { if (clearTimeout(_), _ = void 0, D[O].length !== 0) { const t = D[O].shift(); const e = t[0]; const r = t[1]; const o = t[2]; const n = t[3]; const i = t[4]; if (void 0 === n)W('RETRY', e.name, r), e.apply(null, r); else if (Date.now() - n >= 6e4) { W('TIMEOUT', e.name, r); const c = r.pop(); typeof c === 'function' && c.call(null, o) } else { const s = Date.now() - i; const a = Math.max(i - n, 1); s >= Math.min(1.2 * a, 100) ? (W('RETRY', e.name, r), e.apply(null, r.concat([n]))) : D[O].push(t) } void 0 === _ && (_ = setTimeout(G, 0)) } }process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !D.__patched && ($ = M(D), D.__patched = !0), (function (t) { const e = y.fromCallback; const r = $; const o = ['access', 'appendFile', 'chmod', 'chown', 'close', 'copyFile', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchmod', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'opendir', 'readdir', 'readFile', 'readlink', 'realpath', 'rename', 'rm', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'writeFile'].filter(t => typeof r[t] === 'function'); Object.assign(t, r), o.forEach(o => { t[o] = e(r[o]) }), t.realpath.native = e(r.realpath.native), t.exists = function (t, e) { return typeof e === 'function' ? r.exists(t, e) : new Promise(e => r.exists(t, e)) }, t.read = function (t, e, o, n, i, c) { return typeof c === 'function' ? r.read(t, e, o, n, i, c) : new Promise((c, s) => { r.read(t, e, o, n, i, (t, e, r) => { if (t) return s(t); c({ bytesRead: e, buffer: r }) }) }) }, t.write = function (t, e, ...o) { return typeof o[o.length - 1] === 'function' ? r.write(t, e, ...o) : new Promise((n, i) => { r.write(t, e, ...o, (t, e, r) => { if (t) return i(t); n({ bytesWritten: e, buffer: r }) }) }) }, typeof r.writev === 'function' && (t.writev = function (t, e, ...o) { return typeof o[o.length - 1] === 'function' ? r.writev(t, e, ...o) : new Promise((n, i) => { r.writev(t, e, ...o, (t, e, r) => { if (t) return i(t); n({ bytesWritten: e, buffers: r }) }) }) }) }(m)); const q = {}; const B = {}; const V = d.default; B.checkPath = function (t) { if (process.platform === 'win32') { if (/[<>:"|?*]/.test(t.replace(V.parse(t).root, ''))) { const e = new Error(`Path contains invalid characters: ${t}`); throw e.code = 'EINVAL', e } } }; const H = m; const { checkPath: K } = B; const Y = t => typeof t === 'number' ? t : { mode: 511, ...t }.mode; q.makeDir = async (t, e) => (K(t), H.mkdir(t, { mode: Y(e), recursive: !0 })), q.makeDirSync = (t, e) => (K(t), H.mkdirSync(t, { mode: Y(e), recursive: !0 })); const z = y.fromPromise; const { makeDir: Q, makeDirSync: X } = q; const Z = z(Q); const tt = { mkdirs: Z, mkdirsSync: X, mkdirp: Z, mkdirpSync: X, ensureDir: Z, ensureDirSync: X }; const et = $; const rt = function (t, e, r, o) { et.open(t, 'r+', (t, n) => { if (t) return o(t); et.futimes(n, e, r, t => { et.close(n, e => { o && o(t || e) }) }) }) }; const ot = function (t, e, r) { const o = et.openSync(t, 'r+'); return et.futimesSync(o, e, r), et.closeSync(o) }; const nt = m; const it = d.default; const ct = p.default; function st (t, e, r) { const o = r.dereference ? t => nt.stat(t, { bigint: !0 }) : t => nt.lstat(t, { bigint: !0 }); return Promise.all([o(t), o(e).catch(t => { if (t.code === 'ENOENT') return null; throw t })]).then(([t, e]) => ({ srcStat: t, destStat: e })) } function at (t, e) { return e.ino && e.dev && e.ino === t.ino && e.dev === t.dev } function ut (t, e) { const r = it.resolve(t).split(it.sep).filter(t => t); const o = it.resolve(e).split(it.sep).filter(t => t); return r.reduce((t, e, r) => t && o[r] === e, !0) } function lt (t, e, r) { return `Cannot ${r} '${t}' to a subdirectory of itself, '${e}'.` } const pt = { checkPaths: function (t, e, r, o, n) { ct.callbackify(st)(t, e, o, (o, i) => { if (o) return n(o); const { srcStat: c, destStat: s } = i; if (s) { if (at(c, s)) { const o = it.basename(t); const i = it.basename(e); return r === 'move' && o !== i && o.toLowerCase() === i.toLowerCase() ? n(null, { srcStat: c, destStat: s, isChangingCase: !0 }) : n(new Error('Source and destination must not be the same.')) } if (c.isDirectory() && !s.isDirectory()) return n(new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`)); if (!c.isDirectory() && s.isDirectory()) return n(new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`)) } return c.isDirectory() && ut(t, e) ? n(new Error(lt(t, e, r))) : n(null, { srcStat: c, destStat: s }) }) }, checkPathsSync: function (t, e, r, o) { const { srcStat: n, destStat: i } = (function (t, e, r) { let o; const n = r.dereference ? t => nt.statSync(t, { bigint: !0 }) : t => nt.lstatSync(t, { bigint: !0 }); const i = n(t); try { o = n(e) } catch (t) { if (t.code === 'ENOENT') return { srcStat: i, destStat: null }; throw t } return { srcStat: i, destStat: o } }(t, e, o)); if (i) { if (at(n, i)) { const o = it.basename(t); const c = it.basename(e); if (r === 'move' && o !== c && o.toLowerCase() === c.toLowerCase()) return { srcStat: n, destStat: i, isChangingCase: !0 }; throw new Error('Source and destination must not be the same.') } if (n.isDirectory() && !i.isDirectory()) throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`); if (!n.isDirectory() && i.isDirectory()) throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`) } if (n.isDirectory() && ut(t, e)) throw new Error(lt(t, e, r)); return { srcStat: n, destStat: i } }, checkParentPaths: function t (e, r, o, n, i) { const c = it.resolve(it.dirname(e)); const s = it.resolve(it.dirname(o)); if (s === c || s === it.parse(s).root) return i(); nt.stat(s, { bigint: !0 }, (c, a) => c ? c.code === 'ENOENT' ? i() : i(c) : at(r, a) ? i(new Error(lt(e, o, n))) : t(e, r, s, n, i)) }, checkParentPathsSync: function t (e, r, o, n) { const i = it.resolve(it.dirname(e)); const c = it.resolve(it.dirname(o)); if (c === i || c === it.parse(c).root) return; let s; try { s = nt.statSync(c, { bigint: !0 }) } catch (t) { if (t.code === 'ENOENT') return; throw t } if (at(r, s)) throw new Error(lt(e, o, n)); return t(e, r, c, n) }, isSrcSubdir: ut, areIdentical: at }; const ft = $; const dt = d.default; const ht = tt.mkdirsSync; const wt = ot; const mt = pt; function yt (t, e, r, o) { const n = (o.dereference ? ft.statSync : ft.lstatSync)(e); if (n.isDirectory()) return (function (t, e, r, o, n) { return e ? gt(r, o, n) : (function (t, e, r, o) { return ft.mkdirSync(r), gt(e, r, o), Et(r, t) }(t.mode, r, o, n)) }(n, t, e, r, o)); if (n.isFile() || n.isCharacterDevice() || n.isBlockDevice()) return (function (t, e, r, o, n) { return e ? (function (t, e, r, o) { if (o.overwrite) return ft.unlinkSync(r), St(t, e, r, o); if (o.errorOnExist) throw new Error(`'${r}' already exists`) }(t, r, o, n)) : St(t, r, o, n) }(n, t, e, r, o)); if (n.isSymbolicLink()) return (function (t, e, r, o) { let n = ft.readlinkSync(e); o.dereference && (n = dt.resolve(process.cwd(), n)); if (t) { let t; try { t = ft.readlinkSync(r) } catch (t) { if (t.code === 'EINVAL' || t.code === 'UNKNOWN') return ft.symlinkSync(n, r); throw t } if (o.dereference && (t = dt.resolve(process.cwd(), t)), mt.isSrcSubdir(n, t)) throw new Error(`Cannot copy '${n}' to a subdirectory of itself, '${t}'.`); if (ft.statSync(r).isDirectory() && mt.isSrcSubdir(t, n)) throw new Error(`Cannot overwrite '${t}' with '${n}'.`); return (function (t, e) { return ft.unlinkSync(e), ft.symlinkSync(t, e) }(n, r)) } return ft.symlinkSync(n, r) }(t, e, r, o)); if (n.isSocket()) throw new Error(`Cannot copy a socket file: ${e}`); if (n.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${e}`); throw new Error(`Unknown file: ${e}`) } function St (t, e, r, o) { return ft.copyFileSync(e, r), o.preserveTimestamps && (function (t, e, r) { (function (t) { return (128 & t) == 0 })(t) && (function (t, e) { Et(t, 128 | e) }(r, t)); (function (t, e) { const r = ft.statSync(t); wt(e, r.atime, r.mtime) })(e, r) }(t.mode, e, r)), Et(r, t.mode) } function Et (t, e) { return ft.chmodSync(t, e) } function gt (t, e, r) { ft.readdirSync(t).forEach(o => (function (t, e, r, o) { const n = dt.join(e, t); const i = dt.join(r, t); const { destStat: c } = mt.checkPathsSync(n, i, 'copy', o); return (function (t, e, r, o) { if (!o.filter || o.filter(e, r)) return yt(t, e, r, o) }(c, n, i, o)) }(o, t, e, r))) } const Nt = { copySync: function (t, e, r) { typeof r === 'function' && (r = { filter: r }), (r = r || {}).clobber = !('clobber' in r) || !!r.clobber, r.overwrite = 'overwrite' in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === 'ia32' && console.warn('fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269'); const { srcStat: o, destStat: n } = mt.checkPathsSync(t, e, 'copy', r); return mt.checkParentPathsSync(t, o, e, 'copy'), (function (t, e, r, o) { if (o.filter && !o.filter(e, r)) return; const n = dt.dirname(r); ft.existsSync(n) || ht(n); return yt(t, e, r, o) }(n, t, e, r)) } }; const vt = y.fromPromise; const bt = m; const kt = { pathExists: vt(function (t) { return bt.access(t).then(() => !0).catch(() => !1) }), pathExistsSync: bt.existsSync }; const Ct = $; const Pt = d.default; const Ft = tt.mkdirs; const Ot = kt.pathExists; const Tt = rt; const Dt = pt; function It (t, e, r, o, n) { const i = Pt.dirname(r); Ot(i, (c, s) => c ? n(c) : s ? xt(t, e, r, o, n) : void Ft(i, i => i ? n(i) : xt(t, e, r, o, n))) } function At (t, e, r, o, n, i) { Promise.resolve(n.filter(r, o)).then(c => c ? t(e, r, o, n, i) : i(), t => i(t)) } function xt (t, e, r, o, n) { (o.dereference ? Ct.stat : Ct.lstat)(e, (i, c) => i ? n(i) : c.isDirectory() ? (function (t, e, r, o, n, i) { return e ? Rt(r, o, n, i) : (function (t, e, r, o, n) { Ct.mkdir(r, i => { if (i) return n(i); Rt(e, r, o, e => e ? n(e) : Wt(r, t, n)) }) }(t.mode, r, o, n, i)) }(c, t, e, r, o, n)) : c.isFile() || c.isCharacterDevice() || c.isBlockDevice() ? (function (t, e, r, o, n, i) { return e ? (function (t, e, r, o, n) { if (!o.overwrite) return o.errorOnExist ? n(new Error(`'${r}' already exists`)) : n(); Ct.unlink(r, i => i ? n(i) : Lt(t, e, r, o, n)) }(t, r, o, n, i)) : Lt(t, r, o, n, i) }(c, t, e, r, o, n)) : c.isSymbolicLink() ? (function (t, e, r, o, n) { Ct.readlink(e, (e, i) => e ? n(e) : (o.dereference && (i = Pt.resolve(process.cwd(), i)), t ? void Ct.readlink(r, (e, c) => e ? e.code === 'EINVAL' || e.code === 'UNKNOWN' ? Ct.symlink(i, r, n) : n(e) : (o.dereference && (c = Pt.resolve(process.cwd(), c)), Dt.isSrcSubdir(i, c) ? n(new Error(`Cannot copy '${i}' to a subdirectory of itself, '${c}'.`)) : t.isDirectory() && Dt.isSrcSubdir(c, i) ? n(new Error(`Cannot overwrite '${c}' with '${i}'.`)) : (function (t, e, r) { Ct.unlink(e, o => o ? r(o) : Ct.symlink(t, e, r)) }(i, r, n)))) : Ct.symlink(i, r, n))) }(t, e, r, o, n)) : c.isSocket() ? n(new Error(`Cannot copy a socket file: ${e}`)) : c.isFIFO() ? n(new Error(`Cannot copy a FIFO pipe: ${e}`)) : n(new Error(`Unknown file: ${e}`))) } function Lt (t, e, r, o, n) { Ct.copyFile(e, r, i => i ? n(i) : o.preserveTimestamps ? (function (t, e, r, o) { if (function (t) { return (128 & t) == 0 }(t)) return (function (t, e, r) { return Wt(t, 128 | e, r) }(r, t, n => n ? o(n) : jt(t, e, r, o))); return jt(t, e, r, o) }(t.mode, e, r, n)) : Wt(r, t.mode, n)) } function jt (t, e, r, o) { !(function (t, e, r) { Ct.stat(t, (t, o) => t ? r(t) : Tt(e, o.atime, o.mtime, r)) }(e, r, e => e ? o(e) : Wt(r, t, o))) } function Wt (t, e, r) { return Ct.chmod(t, e, r) } function Rt (t, e, r, o) { Ct.readdir(t, (n, i) => n ? o(n) : _t(i, t, e, r, o)) } function _t (t, e, r, o, n) { const i = t.pop(); return i ? (function (t, e, r, o, n, i) { const c = Pt.join(r, e); const s = Pt.join(o, e); Dt.checkPaths(c, s, 'copy', n, (e, a) => { if (e) return i(e); const { destStat: u } = a; !(function (t, e, r, o, n) { o.filter ? At(xt, t, e, r, o, n) : xt(t, e, r, o, n) }(u, c, s, n, e => e ? i(e) : _t(t, r, o, n, i))) }) }(t, i, e, r, o, n)) : n() } const $t = function (t, e, r, o) { typeof r !== 'function' || o ? typeof r === 'function' && (r = { filter: r }) : (o = r, r = {}), o = o || function () {}, (r = r || {}).clobber = !('clobber' in r) || !!r.clobber, r.overwrite = 'overwrite' in r ? !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === 'ia32' && console.warn('fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269'), Dt.checkPaths(t, e, 'copy', r, (n, i) => { if (n) return o(n); const { srcStat: c, destStat: s } = i; Dt.checkParentPaths(t, c, e, 'copy', n => n ? o(n) : r.filter ? At(It, s, t, e, r, o) : It(s, t, e, r, o)) }) }; const Mt = { copy: (0, y.fromCallback)($t) }; const Ut = $; const Jt = d.default; const Gt = f.default; const qt = process.platform === 'win32'; function Bt (t) { ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'].forEach(e => { t[e] = t[e] || Ut[e], t[e += 'Sync'] = t[e] || Ut[e] }), t.maxBusyTries = t.maxBusyTries || 3 } function Vt (t, e, r) { let o = 0; typeof e === 'function' && (r = e, e = {}), Gt(t, 'rimraf: missing path'), Gt.strictEqual(typeof t, 'string', 'rimraf: path should be a string'), Gt.strictEqual(typeof r, 'function', 'rimraf: callback function required'), Gt(e, 'rimraf: invalid options argument provided'), Gt.strictEqual(typeof e, 'object', 'rimraf: options should be object'), Bt(e), Ht(t, e, function n (i) { if (i) { if ((i.code === 'EBUSY' || i.code === 'ENOTEMPTY' || i.code === 'EPERM') && o < e.maxBusyTries) { o++; return setTimeout(() => Ht(t, e, n), 100 * o) }i.code === 'ENOENT' && (i = null) }r(i) }) } function Ht (t, e, r) { Gt(t), Gt(e), Gt(typeof r === 'function'), e.lstat(t, (o, n) => o && o.code === 'ENOENT' ? r(null) : o && o.code === 'EPERM' && qt ? Kt(t, e, o, r) : n && n.isDirectory() ? zt(t, e, o, r) : void e.unlink(t, o => { if (o) { if (o.code === 'ENOENT') return r(null); if (o.code === 'EPERM') return qt ? Kt(t, e, o, r) : zt(t, e, o, r); if (o.code === 'EISDIR') return zt(t, e, o, r) } return r(o) })) } function Kt (t, e, r, o) { Gt(t), Gt(e), Gt(typeof o === 'function'), e.chmod(t, 438, n => { n ? o(n.code === 'ENOENT' ? null : r) : e.stat(t, (n, i) => { n ? o(n.code === 'ENOENT' ? null : r) : i.isDirectory() ? zt(t, e, r, o) : e.unlink(t, o) }) }) } function Yt (t, e, r) { let o; Gt(t), Gt(e); try { e.chmodSync(t, 438) } catch (t) { if (t.code === 'ENOENT') return; throw r } try { o = e.statSync(t) } catch (t) { if (t.code === 'ENOENT') return; throw r }o.isDirectory() ? Xt(t, e, r) : e.unlinkSync(t) } function zt (t, e, r, o) { Gt(t), Gt(e), Gt(typeof o === 'function'), e.rmdir(t, n => { !n || n.code !== 'ENOTEMPTY' && n.code !== 'EEXIST' && n.code !== 'EPERM' ? n && n.code === 'ENOTDIR' ? o(r) : o(n) : (function (t, e, r) { Gt(t), Gt(e), Gt(typeof r === 'function'), e.readdir(t, (o, n) => { if (o) return r(o); let i; let c = n.length; if (c === 0) return e.rmdir(t, r); n.forEach(o => { Vt(Jt.join(t, o), e, o => { if (!i) return o ? r(i = o) : void (--c == 0 && e.rmdir(t, r)) }) }) }) }(t, e, o)) }) } function Qt (t, e) { let r; Bt(e = e || {}), Gt(t, 'rimraf: missing path'), Gt.strictEqual(typeof t, 'string', 'rimraf: path should be a string'), Gt(e, 'rimraf: missing options'), Gt.strictEqual(typeof e, 'object', 'rimraf: options should be object'); try { r = e.lstatSync(t) } catch (r) { if (r.code === 'ENOENT') return; r.code === 'EPERM' && qt && Yt(t, e, r) } try { r && r.isDirectory() ? Xt(t, e, null) : e.unlinkSync(t) } catch (r) { if (r.code === 'ENOENT') return; if (r.code === 'EPERM') return qt ? Yt(t, e, r) : Xt(t, e, r); if (r.code !== 'EISDIR') throw r; Xt(t, e, r) } } function Xt (t, e, r) { Gt(t), Gt(e); try { e.rmdirSync(t) } catch (o) { if (o.code === 'ENOTDIR') throw r; if (o.code === 'ENOTEMPTY' || o.code === 'EEXIST' || o.code === 'EPERM')!(function (t, e) { if (Gt(t), Gt(e), e.readdirSync(t).forEach(r => Qt(Jt.join(t, r), e)), !qt) { return e.rmdirSync(t, e) } { const r = Date.now(); do { try { return e.rmdirSync(t, e) } catch {} } while (Date.now() - r < 500) } }(t, e)); else if (o.code !== 'ENOENT') throw o } } const Zt = Vt; Vt.sync = Qt; const te = $; const ee = y.fromCallback; const re = Zt; const oe = { remove: ee(function (t, e) { if (te.rm) return te.rm(t, { recursive: !0, force: !0 }, e); re(t, e) }), removeSync: function (t) { if (te.rmSync) return te.rmSync(t, { recursive: !0, force: !0 }); re.sync(t) } }; const ne = y.fromPromise; const ie = m; const ce = d.default; const se = tt; const ae = oe; const ue = ne(async function (t) { let e; try { e = await ie.readdir(t) } catch { return se.mkdirs(t) } return Promise.all(e.map(e => ae.remove(ce.join(t, e)))) }); function le (t) { let e; try { e = ie.readdirSync(t) } catch { return se.mkdirsSync(t) }e.forEach(e => { e = ce.join(t, e), ae.removeSync(e) }) } const pe = { emptyDirSync: le, emptydirSync: le, emptyDir: ue, emptydir: ue }; const fe = y.fromCallback; const de = d.default; const he = $; const we = tt; const me = { createFile: fe(function (t, e) { function r () { he.writeFile(t, '', t => { if (t) return e(t); e() }) }he.stat(t, (o, n) => { if (!o && n.isFile()) return e(); const i = de.dirname(t); he.stat(i, (t, o) => { if (t) return t.code === 'ENOENT' ? we.mkdirs(i, t => { if (t) return e(t); r() }) : e(t); o.isDirectory() ? r() : he.readdir(i, t => { if (t) return e(t) }) }) }) }), createFileSync: function (t) { let e; try { e = he.statSync(t) } catch {} if (e && e.isFile()) return; const r = de.dirname(t); try { he.statSync(r).isDirectory() || he.readdirSync(r) } catch (t) { if (!t || t.code !== 'ENOENT') throw t; we.mkdirsSync(r) }he.writeFileSync(t, '') } }; const ye = y.fromCallback; const Se = d.default; const Ee = $; const ge = tt; const Ne = kt.pathExists; const { areIdentical: ve } = pt; const be = { createLink: ye(function (t, e, r) { function o (t, e) { Ee.link(t, e, t => { if (t) return r(t); r(null) }) }Ee.lstat(e, (n, i) => { Ee.lstat(t, (n, c) => { if (n) return n.message = n.message.replace('lstat', 'ensureLink'), r(n); if (i && ve(c, i)) return r(null); const s = Se.dirname(e); Ne(s, (n, i) => n ? r(n) : i ? o(t, e) : void ge.mkdirs(s, n => { if (n) return r(n); o(t, e) })) }) }) }), createLinkSync: function (t, e) { let r; try { r = Ee.lstatSync(e) } catch {} try { const e = Ee.lstatSync(t); if (r && ve(e, r)) return } catch (t) { throw t.message = t.message.replace('lstat', 'ensureLink'), t } const o = Se.dirname(e); return Ee.existsSync(o) || ge.mkdirsSync(o), Ee.linkSync(t, e) } }; const ke = d.default; const Ce = $; const Pe = kt.pathExists; const Fe = { symlinkPaths: function (t, e, r) { if (ke.isAbsolute(t)) return Ce.lstat(t, e => e ? (e.message = e.message.replace('lstat', 'ensureSymlink'), r(e)) : r(null, { toCwd: t, toDst: t })); { const o = ke.dirname(e); const n = ke.join(o, t); return Pe(n, (e, i) => e ? r(e) : i ? r(null, { toCwd: n, toDst: t }) : Ce.lstat(t, e => e ? (e.message = e.message.replace('lstat', 'ensureSymlink'), r(e)) : r(null, { toCwd: t, toDst: ke.relative(o, t) }))) } }, symlinkPathsSync: function (t, e) { let r; if (ke.isAbsolute(t)) { if (r = Ce.existsSync(t), !r) throw new Error('absolute srcpath does not exist'); return { toCwd: t, toDst: t } } { const o = ke.dirname(e); const n = ke.join(o, t); if (r = Ce.existsSync(n), r) return { toCwd: n, toDst: t }; if (r = Ce.existsSync(t), !r) throw new Error('relative srcpath does not exist'); return { toCwd: t, toDst: ke.relative(o, t) } } } }; const Oe = $; const Te = { symlinkType: function (t, e, r) { if (r = typeof e === 'function' ? e : r, e = typeof e !== 'function' && e) return r(null, e); Oe.lstat(t, (t, o) => { if (t) return r(null, 'file'); e = o && o.isDirectory() ? 'dir' : 'file', r(null, e) }) }, symlinkTypeSync: function (t, e) { let r; if (e) return e; try { r = Oe.lstatSync(t) } catch { return 'file' } return r && r.isDirectory() ? 'dir' : 'file' } }; const De = y.fromCallback; const Ie = d.default; const Ae = m; const xe = tt.mkdirs; const Le = tt.mkdirsSync; const je = Fe.symlinkPaths; const We = Fe.symlinkPathsSync; const Re = Te.symlinkType; const _e = Te.symlinkTypeSync; const $e = kt.pathExists; const { areIdentical: Me } = pt; function Ue (t, e, r, o) { je(t, e, (n, i) => { if (n) return o(n); t = i.toDst, Re(i.toCwd, r, (r, n) => { if (r) return o(r); const i = Ie.dirname(e); $e(i, (r, c) => r ? o(r) : c ? Ae.symlink(t, e, n, o) : void xe(i, r => { if (r) return o(r); Ae.symlink(t, e, n, o) })) }) }) } const Je = { createSymlink: De(function (t, e, r, o) { o = typeof r === 'function' ? r : o, r = typeof r !== 'function' && r, Ae.lstat(e, (n, i) => { !n && i.isSymbolicLink() ? Promise.all([Ae.stat(t), Ae.stat(e)]).then(([n, i]) => { if (Me(n, i)) return o(null); Ue(t, e, r, o) }) : Ue(t, e, r, o) }) }), createSymlinkSync: function (t, e, r) { let o; try { o = Ae.lstatSync(e) } catch {} if (o && o.isSymbolicLink()) { const r = Ae.statSync(t); const o = Ae.statSync(e); if (Me(r, o)) return } const n = We(t, e); t = n.toDst, r = _e(n.toCwd, r); const i = Ie.dirname(e); return Ae.existsSync(i) || Le(i), Ae.symlinkSync(t, e, r) } }; const Ge = { createFile: me.createFile, createFileSync: me.createFileSync, ensureFile: me.createFile, ensureFileSync: me.createFileSync, createLink: be.createLink, createLinkSync: be.createLinkSync, ensureLink: be.createLink, ensureLinkSync: be.createLinkSync, createSymlink: Je.createSymlink, createSymlinkSync: Je.createSymlinkSync, ensureSymlink: Je.createSymlink, ensureSymlinkSync: Je.createSymlinkSync }; const qe = { stringify: function (t, { EOL: e = '\n', finalEOL: r = !0, replacer: o = null, spaces: n } = {}) { const i = r ? e : ''; return JSON.stringify(t, o, n).replace(/\n/g, e) + i }, stripBom: function (t) { return Buffer.isBuffer(t) && (t = t.toString('utf8')), t.replace(/^\uFEFF/, '') } }; let Be; try { Be = require('graceful-fs') } catch (t) { Be = a.default } const Ve = y; const { stringify: He, stripBom: Ke } = qe; const Ye = Ve.fromPromise(async function (t, e = {}) { typeof e === 'string' && (e = { encoding: e }); const r = e.fs || Be; const o = !('throws' in e) || e.throws; let n; let i = await Ve.fromCallback(r.readFile)(t, e); i = Ke(i); try { n = JSON.parse(i, e ? e.reviver : null) } catch (e) { if (o) throw e.message = `${t}: ${e.message}`, e; return null } return n }); const ze = Ve.fromPromise(async function (t, e, r = {}) { const o = r.fs || Be; const n = He(e, r); await Ve.fromCallback(o.writeFile)(t, n, r) }); const Qe = { readFile: Ye, readFileSync: function (t, e = {}) { typeof e === 'string' && (e = { encoding: e }); const r = e.fs || Be; const o = !('throws' in e) || e.throws; try { let o = r.readFileSync(t, e); return o = Ke(o), JSON.parse(o, e.reviver) } catch (e) { if (o) throw e.message = `${t}: ${e.message}`, e; return null } }, writeFile: ze, writeFileSync: function (t, e, r = {}) { const o = r.fs || Be; const n = He(e, r); return o.writeFileSync(t, n, r) } }; const Xe = { readJson: Qe.readFile, readJsonSync: Qe.readFileSync, writeJson: Qe.writeFile, writeJsonSync: Qe.writeFileSync }; const Ze = y.fromCallback; const tr = $; const er = d.default; const rr = tt; const or = kt.pathExists; const nr = { outputFile: Ze(function (t, e, r, o) { typeof r === 'function' && (o = r, r = 'utf8'); const n = er.dirname(t); or(n, (i, c) => i ? o(i) : c ? tr.writeFile(t, e, r, o) : void rr.mkdirs(n, n => { if (n) return o(n); tr.writeFile(t, e, r, o) })) }), outputFileSync: function (t, ...e) { const r = er.dirname(t); if (tr.existsSync(r)) return tr.writeFileSync(t, ...e); rr.mkdirsSync(r), tr.writeFileSync(t, ...e) } }; const { stringify: ir } = qe; const { outputFile: cr } = nr; const sr = async function (t, e, r = {}) { const o = ir(e, r); await cr(t, o, r) }; const { stringify: ar } = qe; const { outputFileSync: ur } = nr; const lr = function (t, e, r) { const o = ar(e, r); ur(t, o, r) }; const pr = y.fromPromise; const fr = Xe; fr.outputJson = pr(sr), fr.outputJsonSync = lr, fr.outputJSON = fr.outputJson, fr.outputJSONSync = fr.outputJsonSync, fr.writeJSON = fr.writeJson, fr.writeJSONSync = fr.writeJsonSync, fr.readJSON = fr.readJson, fr.readJSONSync = fr.readJsonSync; const dr = fr; const hr = $; const wr = d.default; const mr = Nt.copySync; const yr = oe.removeSync; const Sr = tt.mkdirpSync; const Er = pt; function gr (t, e, r) { try { hr.renameSync(t, e) } catch (o) { if (o.code !== 'EXDEV') throw o; return (function (t, e, r) { return mr(t, e, { overwrite: r, errorOnExist: true }), yr(t) }(t, e, r)) } } const Nr = { moveSync: function (t, e, r) { const o = (r = r || {}).overwrite || r.clobber || !1; const { srcStat: n, isChangingCase: i = !1 } = Er.checkPathsSync(t, e, 'move', r); return Er.checkParentPathsSync(t, n, e, 'move'), (function (t) { const e = wr.dirname(t); return wr.parse(e).root === e }(e)) || Sr(wr.dirname(e)), (function (t, e, r, o) { if (o) return gr(t, e, r); if (r) return yr(e), gr(t, e, r); if (hr.existsSync(e)) throw new Error('dest already exists.'); return gr(t, e, r) }(t, e, o, i)) } }; const vr = $; const br = d.default; const kr = Mt.copy; const Cr = oe.remove; const Pr = tt.mkdirp; const Fr = kt.pathExists; const Or = pt; function Tr (t, e, r, o, n) { return o ? Dr(t, e, r, n) : r ? Cr(e, o => o ? n(o) : Dr(t, e, r, n)) : void Fr(e, (o, i) => o ? n(o) : i ? n(new Error('dest already exists.')) : Dr(t, e, r, n)) } function Dr (t, e, r, o) { vr.rename(t, e, n => n ? n.code !== 'EXDEV' ? o(n) : (function (t, e, r, o) { kr(t, e, { overwrite: r, errorOnExist: !0 }, e => e ? o(e) : Cr(t, o)) }(t, e, r, o)) : o()) } const Ir = function (t, e, r, o) { typeof r === 'function' && (o = r, r = {}); const n = r.overwrite || r.clobber || !1; Or.checkPaths(t, e, 'move', r, (r, i) => { if (r) return o(r); const { srcStat: c, isChangingCase: s = !1 } = i; Or.checkParentPaths(t, c, e, 'move', r => r ? o(r) : (function (t) { const e = br.dirname(t); return br.parse(e).root === e }(e)) ? Tr(t, e, n, s, o) : void Pr(br.dirname(e), r => r ? o(r) : Tr(t, e, n, s, o))) }) }; let Ar; const xr = { move: (0, y.fromCallback)(Ir) }; const Lr = { ...m, ...Nt, ...Mt, ...pe, ...Ge, ...dr, ...tt, ...Nr, ...xr, ...nr, ...kt, ...oe }; !(function (t) { t.configurations = { getRootCategories: function () { return Object.values(n().children || {}).map(t => c(t)) }, getCategories: function (t) { const e = i(t); return Object.values(e.children || {}).map(t => c(t)) }, getCategory: function (t) { const e = i(t); return e ? c(e) : null }, removeCategory: function (t) { const e = t.split('/'); const r = e.pop(); const o = e.length ? i(e.join('/')) : n(); delete o.children[r], o.instance && o.instance.invalidateSubCategories() }, getElements: function (t) { const e = i(t); if (!e) return []; const r = c(e); return Object.values(e.elements).map(t => s(t, r)) }, getElement: function (t, e) { const r = i(t); if (!r) return null; const o = c(r); const n = r.elements[e]; if (!n) return null; return s(n, o) }, createElement: function (t, e) { const r = t.split('/').reduce((t, e) => { let r = t.children[e]; return r || (r = { name: e, path: t.path ? `${t.path}/${e}` : e, parent: t, elements: {}, children: {} }, t.children[e] = r), r }, n()); const o = c(r); o.invalidateElements(); const i = { name: e }; return r.elements[e] = i, s(i, o) }, removeElement: function (t, e) { const r = i(t); if (!r) throw new Error(`Configuration category with path '${t}' does not exist.`); delete r.elements[e], r.instance && r.instance.invalidateElements() }, getElementAttributes: function (e, r) { const o = i(e); if (!o) return []; const n = o.elements[r]; if (!n || !n.path) return []; return t.parseJsonFile(n.path).map(e => { const r = new t.Attribute(); return r.name = e.name, r.description = e.description, r.type = e.type, r.value = e.value != null ? u(e.type, e.value) : null, r }) } }; const e = Lr; const r = 'vro-configurations.json'; let o; function n () { return o || (o = { children: a(e.existsSync(r) ? t.parseJsonFile(r) : {}) }) } function i (t) { return t.split('/').reduce((t, e) => t ? t.children[e] : null, n()) } function c (e) { let r; if (!e.instance) { const o = e.instance = new t.ConfigurationElementCategory(); o.name = e.name, o.description = e.description, o.path = e.path, o.parent = (r = e.parent) === null || void 0 === r ? void 0 : r.instance } return e.instance } function s (e, r) { if (!e.instance) { const o = e.instance = new t.ConfigurationElement(); o.name = e.name, o.description = e.description, o.version = e.version, o.configurationElementCategory = r } return e.instance } function a (t, e) { for (const [r, o] of Object.entries(t)) { o.name = r, o.path = e ? `${e.path}/${r}` : r, o.parent = e, o.elements = o.elements || {}; for (const [t, e] of Object.entries(o.elements))e.name = t; o.children = a(o.children || {}, o) } return t } function u (t, e) { if (e === '__NULL__') return null; const r = 'Array/'; if (t.startsWith(r)) return (function (t, e) { let r = e.toString(); r.substring(0, 2) === '#{' && (r = r.substring(2)); r.substring(r.length - 2) === '}#' && (r = r.substring(0, r.length - 2)); const o = `#${t}#`; return r.split(';').map(e => (e = (e = e.substring(o.length)).substring(0, e.length - 1), u(t, e))) }(t.substring(r.length), e)); switch (t) { case 'string':return e; case 'boolean':return e.toString() === 'true'; case 'number':return parseFloat(e.toString()); default: } } }(Ar || (Ar = {}))), (function (t) { class e extends Error {constructor (t = 'Not implemented!') { super(t), this.message = t }}t.NotSupportedError = e }(Ar || (Ar = {}))), (function (t) { t.logger = { info: function (t) { c(t, 'INFO') }, warn: function (t) { c(t, 'WARN') }, error: function (t) { c(t, 'ERROR') }, debug: function (t) { c(t, 'DEBUG') }, stdout: function (r) { e.appendFileSync(i, `${t.formatDate(new Date())}}\n${r}\n`) }, log: c }; const e = Lr; const r = d.default; const o = 'logs'; const n = r.join(o, 'scripting.log'); const i = r.join(o, 'stdout.log'); function c (r, o) { e.appendFileSync(n, `[${t.formatDate(new Date())}] [${o}] ${r}\n`) }e.existsSync(o) || e.mkdirSync(o) }(Ar || (Ar = {}))), (function (t) { t.modules = { getModule: c, getAllModules: function () { return Object.keys(i()).map(t => c(t)) } }; const e = Lr; const r = 'vro-modules.json'; const o = {}; let n; function i () { return n || (n = e.existsSync(r) ? t.parseJsonFile(r) : {}) } function c (r) { return o[r] || (o[r] = (function (r) { const o = i()[r]; if (!o) return null; const n = []; const c = new t.Module(); return c.name = r, c.actions = n, c.actionDescriptions = n, Object.entries(o).forEach(([r, o]) => { const i = `${process.cwd()}/${o}`; c[r] = (...t) => require(i).apply(void 0, t); const s = new t.Action(); s.name = r, s.module = c, s.script = e.readFileSync(i).toString('utf-8'), n.push(s) }), c }(r))) } }(Ar || (Ar = {}))), (function (t) { t.resources = { getRootCategories: function () { return Object.values(n().children || {}).map(t => c(t)) }, getCategories: function (t) { const e = i(t); return Object.values(e.children || {}).map(t => c(t)) }, getCategory: function (t) { const e = i(t); return e ? c(e) : null }, removeCategory: function (t) { const e = t.split('/'); const r = e.pop(); const o = e.length ? i(e.join('/')) : n(); delete o.children[r], o.instance && o.instance.invalidateSubCategories() }, getElements: function (t) { const e = i(t); if (!e) return []; const r = c(e); return Object.values(e.elements).map(t => s(t, r)) }, getElement: function (t, e) { const r = i(t); if (!r) return null; const o = c(r); const n = r.elements[e]; if (!n) return null; return s(n, o) }, createElement: function (t, e) { const r = t.split('/').reduce((t, e) => { let r = t.children[e]; return r || (r = { name: e, path: t.path ? `${t.path}/${e}` : e, parent: t, elements: {}, children: {} }, t.children[e] = r), r }, n()); const o = c(r); o.invalidateElements(); const i = { name: e }; return r.elements[e] = i, s(i, o) }, removeElement: function (t, e) { const r = i(t); if (!r) throw new Error(`Configuration category with path '${t}' does not exist.`); delete r.elements[e], r.instance && r.instance.invalidateElements() }, getElementContent: function (t, r) { const o = i(t); if (!o) return null; const n = o.elements[r]; if (!n || !n.path) return null; return e.readFileSync(n.path).toString('utf-8') } }; const e = Lr; const r = 'vro-resources.json'; let o; function n () { return o || (o = { children: a(e.existsSync(r) ? t.parseJsonFile(r) : {}) }) } function i (t) { return t.split('/').reduce((t, e) => t ? t.children[e] : null, n()) } function c (e) { let r; if (!e.instance) { const o = e.instance = new t.ResourceElementCategory(); o.name = e.name, o.description = e.description, o.path = e.path, o.parent = (r = e.parent) === null || void 0 === r ? void 0 : r.instance } return e.instance } function s (e, r) { if (!e.instance) { const o = e.instance = new t.ResourceElement(); o.name = e.name, o.description = e.description, o.version = e.version, o.resourceElementCategory = r } return e.instance } function a (t, e) { for (const [r, o] of Object.entries(t)) { o.name = r, o.path = e ? `${e.path}/${r}` : r, o.parent = e, o.elements = o.elements || {}; for (const [t, e] of Object.entries(o.elements))e.name = t; o.children = a(o.children || {}, o) } return t } }(Ar || (Ar = {}))), (function (t) { const e = Lr; t.parseJsonFile = function (t) { const r = e.readFileSync(t).toString('utf-8'); return JSON.parse(r) }, t.formatDate = function (t) { return t.toISOString().replace(/T/, ' ').replace(/\..+/, '') } }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.versionHistoryItems = [], this.parameters = [], this.module = new t.Module() }}t.Action = e, w.Action = e }(Ar || (Ar = {}))), (function (t) { class e {getResult () { throw new t.NotSupportedError() }cancel (e) { throw new t.NotSupportedError() }isDone () { throw new t.NotSupportedError() }}t.ActionResult = e, w.ActionResult = e }(Ar || (Ar = {}))), (function (t) { class e {}t.Attribute = e, w.Attribute = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.references = [] }addReference (e, r) { throw new t.NotSupportedError() }removeAllReferences () { throw new t.NotSupportedError() }removeReference (e, r) { throw new t.NotSupportedError() }}t.AuthorizationElement = e, w.AuthorizationElement = e }(Ar || (Ar = {}))), (function (t) { class e {}t.AuthorizationReference = e, w.AuthorizationReference = e }(Ar || (Ar = {}))), (function (t) { class e {execute (e) { throw new t.NotSupportedError() }executeAndLog (e) { throw new t.NotSupportedError() }}t.Command = e, w.Command = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.versionHistoryItems = [] } get attributes () { return this._attributes || (this._attributes = t.configurations.getElementAttributes(this.configurationElementCategory.path, this.name)) }getAttributeWithKey (t) { return this.attributes.find(e => e.name === t) }setAttributeWithKey (e, r, o) { let n = this.getAttributeWithKey(e); n || (n = new t.Attribute(), n.name = e, this._attributes.push(n)), n.value = r, n.type = o }removeAttributeWithKey (t) { const e = this.attributes.findIndex(e => e.name === t); this.attributes.splice(e, 1) }saveToVersionRepository () { throw new t.NotSupportedError() }reload () {}}t.ConfigurationElement = e, w.ConfigurationElement = e }(Ar || (Ar = {}))), (function (t) { class e {get configurationElements () { return this._configurationElements || (this._configurationElements = t.configurations.getElements(this.path)) } get allConfigurationElements () { return this.configurationElements } get subCategories () { return this._subCategories || (this._subCategories = t.configurations.getCategories(this.path)) }invalidateElements () { this._configurationElements = null }invalidateSubCategories () { this._subCategories = null }}t.ConfigurationElementCategory = e, w.ConfigurationElementCategory = e }(Ar || (Ar = {}))), (function (t) { class e {checkPassword (e) { throw new t.NotSupportedError() }}t.Credential = e, w.Credential = e }(Ar || (Ar = {}))), (function (t) { class e extends String {}t.EncryptedString = e, w.EncryptedString = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.hasNext = !1 }}t.Enumeration = e, w.Enumeration = e }(Ar || (Ar = {}))), (function (t) { class e {consume (e) { throw new t.NotSupportedError() }}t.Event = e, w.Event = e }(Ar || (Ar = {}))), (function (t) { class e {consume (e) { throw new t.NotSupportedError() }}t.EventGauge = e, w.EventGauge = e }(Ar || (Ar = {}))), (function (t) { class e {consume (e) { throw new t.NotSupportedError() }}t.EventSchedule = e, w.EventSchedule = e }(Ar || (Ar = {}))), (function (t) { class e {consume (e) { throw new t.NotSupportedError() }getValue (e) { throw new t.NotSupportedError() }}t.EventTrigger = e, w.EventTrigger = e }(Ar || (Ar = {}))), (function (t) { class e {contains (e) { throw new t.NotSupportedError() }getParameter (e) { throw new t.NotSupportedError() }parameterNames (e) { throw new t.NotSupportedError() }}t.ExecutionContext = e, w.ExecutionContext = e }(Ar || (Ar = {}))), (function (t) { class e {constructor (e) { throw new t.NotSupportedError() }write (e) { throw new t.NotSupportedError() }renameTo (e) { throw new t.NotSupportedError() }createFile () { throw new t.NotSupportedError() }createDirectory () { throw new t.NotSupportedError() }deleteFile () { throw new t.NotSupportedError() }list (e) { throw new t.NotSupportedError() }canRead () { throw new t.NotSupportedError() }canWrite () { throw new t.NotSupportedError() }}t.File = e, w.File = e }(Ar || (Ar = {}))), (function (t) { class e {}t.FileHelper = e, w.FileHelper = e }(Ar || (Ar = {}))), (function (t) { class e {constructor (e) { throw new t.NotSupportedError() }open () { throw new t.NotSupportedError() }readLine () { throw new t.NotSupportedError() }readAll () { throw new t.NotSupportedError() }}t.FileReader = e, w.FileReader = e }(Ar || (Ar = {}))), (function (t) { class e {constructor (e) { throw new t.NotSupportedError() }open () { throw new t.NotSupportedError() }clean () { throw new t.NotSupportedError() }writeLine (e) { throw new t.NotSupportedError() }write (e) { throw new t.NotSupportedError() }close () { throw new t.NotSupportedError() }}t.FileWriter = e, w.FileWriter = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.parentGroups = [], this.subGroups = [], this.users = [] }}t.LdapGroup = e, w.LdapGroup = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.groups = [], this.allGroups = [] }isMemberOfGroup (e) { throw new t.NotSupportedError() }}t.LdapUser = e, w.LdapUser = e }(Ar || (Ar = {}))), (function (t) { class e {lock (e, r) { throw new t.NotSupportedError() }lockAndWait (e, r) { throw new t.NotSupportedError() }unlock (e, r) { throw new t.NotSupportedError() }unlockAll () { throw new t.NotSupportedError() }retrieveAll () { throw new t.NotSupportedError() }}t.LockingSystem = e, w.LockingSystem = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.logTimeStamp = '' }}t.LogEvent = e, w.LogEvent = e }(Ar || (Ar = {}))), (function (t) { class e {open () { throw new t.NotSupportedError() }clean () { throw new t.NotSupportedError() }writeLine (e) { throw new t.NotSupportedError() }write (e) { throw new t.NotSupportedError() }close () { throw new t.NotSupportedError() }}t.LogFileWriter = e, w.LogFileWriter = e }(Ar || (Ar = {}))), (function (t) { class e {}t.LogQuery = e, w.LogQuery = e }(Ar || (Ar = {}))), (function (t) { class e {constructor (t) {}write (e, r) { throw new t.NotSupportedError() }}t.MimeAttachment = e, w.MimeAttachment = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.actions = [], this.actionDescriptions = [] }}t.Module = e, w.Module = e }(Ar || (Ar = {}))), (function (t) { class e {}t.NotFound = e, w.NotFound = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.policyTemplates = [], this.actions = [], this.workflows = [], this.resourceElements = [], this.configurationElements = [] }remove () { throw new t.NotSupportedError() }}t.Package = e, w.Package = e }(Ar || (Ar = {}))), (function (t) { class e {}t.Parameter = e, w.Parameter = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.types = [] }}t.PluginModuleDescription = e, w.PluginModuleDescription = e }(Ar || (Ar = {}))), (function (t) { class e {}t.PluginTypeDescription = e, w.PluginTypeDescription = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.taggedObjects = [], this.tags = [], this.logEvents = [] }getObjectByTag (e) { throw new t.NotSupportedError() }forTag (e) { throw new t.NotSupportedError() }exit (e) { throw new t.NotSupportedError() }getEventsByTag () { throw new t.NotSupportedError() }start () { throw new t.NotSupportedError() }stop (e) { throw new t.NotSupportedError() }remove () { throw new t.NotSupportedError() }}t.Policy = e, w.Policy = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.versionHistoryItems = [], this.policyTemplateCategory = '' }apply (e, r) { throw new t.NotSupportedError() }getObjectByTag (e) { throw new t.NotSupportedError() }forTag (e) { throw new t.NotSupportedError() }}t.PolicyTemplate = e, w.PolicyTemplate = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.policyTemplates = [], this.subCategories = [], this.allPolicyTemplates = [] }}t.PolicyTemplateCategory = e, w.PolicyTemplateCategory = e }(Ar || (Ar = {}))), (function (t) { function e (t) { const e = Object.assign({}, t); const r = { get: t => e[t], put: (t, r) => { e[t] = r }, remove: t => { delete e[t] }, load: t => { Object.entries(t || {}).forEach(([t, r]) => { e[t] = r }) } }; return new Proxy(e, { get: (t, o) => r[o] || e[o] }) }t.Properties = e, w.Properties = e }(Ar || (Ar = {}))), (function (t) { class e {}t.QueryResult = e, w.QueryResult = e }(Ar || (Ar = {}))), (function (t) { class e extends RegExp {}t.Regexp = e, w.Regexp = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.mimeType = 'application/octet-stream', this.versionHistoryItems = [] }getContentAsMimeAttachment () { return this._mimeAttachment || (this._mimeAttachment = new t.MimeAttachment(), this._mimeAttachment.name = this.name, this._mimeAttachment.mimeType = this.mimeType, this._mimeAttachment.content = t.resources.getElementContent(this.resourceElementCategory.path, this.name)), this._mimeAttachment }getResourceElementCategory () { return this.resourceElementCategory }reload () {}setContentFromFile (e, r) { throw new t.NotSupportedError() }setContentFromMimeAttachment (t) { this._mimeAttachment = t, this.mimeType = t.mimeType }writeContentToFile (t) {}saveToVersionRepository () {}}t.ResourceElement = e, w.ResourceElement = e }(Ar || (Ar = {}))), (function (t) { class e {get resourceElements () { return this._resourceElements || (this._resourceElements = t.resources.getElements(this.path)) } get allResourceElements () { return this.resourceElements } get subCategories () { return this._subCategories || (this._subCategories = t.resources.getCategories(this.path)) }invalidateElements () { this._resourceElements = null }invalidateSubCategories () { this._subCategories = null }}t.ResourceElementCategory = e, w.ResourceElementCategory = e }(Ar || (Ar = {}))), (function (t) { class e {}t.SDKObject = e, w.SDKObject = e }(Ar || (Ar = {}))), (function (t) { class e extends String {}t.SecureString = e, w.SecureString = e }(Ar || (Ar = {}))), (function (t) { class e {static createAuthorizationElement (e, r, o) { throw new t.NotSupportedError() } static createConfigurationElement (e, r) { const o = typeof e === 'string' ? e : e.path; return t.configurations.createElement(o, r) } static createResourceElement (e, r, o, n) { const i = typeof e === 'string' ? e : e.path; return t.resources.createElement(i, r) } static error (e, r) { throw new t.NotSupportedError() } static fetchLogEvents (e) { throw new t.NotSupportedError() } static findAllForType (e, r) { throw new t.NotSupportedError() } static findForType (e, r) { throw new t.NotSupportedError() } static findGlobalTagsForObject (e) { throw new t.NotSupportedError() } static findTagsForObject (e) { throw new t.NotSupportedError() } static findTagsInUse () { throw new t.NotSupportedError() } static fromStringRepresentation (e) { throw new t.NotSupportedError() } static fromUri (e) { throw new t.NotSupportedError() } static getAllConfigurationElementCategories () { return t.configurations.getRootCategories() } static getAllDescriptionsForType (e) { throw new t.NotSupportedError() } static getAllDisplayNamesForType (e) { throw new t.NotSupportedError() } static getAllNamesForType (e) { throw new t.NotSupportedError() } static getAllPluginInfo () { throw new t.NotSupportedError() } static getAllPluginTypes () { throw new t.NotSupportedError() } static getAllPolicyTemplateCategories () { throw new t.NotSupportedError() } static getAllResourceElementCategories () { return t.resources.getRootCategories() } static getAllWorkflowCategories () { throw new t.NotSupportedError() } static getAuthorizationElementForName (e) { throw new t.NotSupportedError() } static getAuthorizationElementsForLdapElement (e) { throw new t.NotSupportedError() } static getConfigurationElementCategoryWithPath (e) { return t.configurations.getCategory(e) } static getCredential () { throw new t.NotSupportedError() } static getCurrentLdapUser () { throw new t.NotSupportedError() } static getCustomProperty (e, r) { throw new t.NotSupportedError() } static getCustomPropertyKeys (e) { throw new t.NotSupportedError() } static getLdapElement (e) { throw new t.NotSupportedError() } static getObjectsURIWithCustomPropertyKey (e) { throw new t.NotSupportedError() } static getObjectsWithCustomPropertyKey (e) { throw new t.NotSupportedError() } static getPackageWithName (e) { throw new t.NotSupportedError() } static getPluginTypeInfo (e) { throw new t.NotSupportedError() } static getPolicyTemplateCategoryWithPath (e) { throw new t.NotSupportedError() } static getResourceElementCategoryWithPath (e) { return t.resources.getCategory(e) } static getRunningUser () { throw new t.NotSupportedError() } static getSignatureFingerPrint (e) { throw new t.NotSupportedError() } static getSignatureOwner (e) { throw new t.NotSupportedError() } static getWorkflowCategoryWithPath (e) { throw new t.NotSupportedError() } static getWorkflowTokenState (e) { throw new t.NotSupportedError() } static getWorkflowWithId (e) { throw new t.NotSupportedError() } static isValidLdapCredential (e) { throw new t.NotSupportedError() } static log (e, r) { throw new t.NotSupportedError() } static query (e, r, o) { throw new t.NotSupportedError() } static queryByTags (e, r) { throw new t.NotSupportedError() } static removeAccessRights (e, r) { throw new t.NotSupportedError() } static removeAllCustomPropertiesForObject (e) { throw new t.NotSupportedError() } static removeAllCustomPropertiesForType (e) { throw new t.NotSupportedError() } static removeAllCustomPropertiesForTypeAndKey (e, r) { throw new t.NotSupportedError() } static removeConfigurationElement (e) { t.configurations.removeElement(e.configurationElementCategory.path, e.name) } static removeConfigurationElementCategory (e) { t.configurations.removeCategory(e.path) } static removeAuthorizationElement (e) { throw new t.NotSupportedError() } static removeCustomProperty (e, r) { throw new t.NotSupportedError() } static removeResourceElement (e) { t.resources.removeElement(e.resourceElementCategory.path, e.name) } static searchLdapGroups (e, r) { throw new t.NotSupportedError() } static searchLdapUsers (e, r) { throw new t.NotSupportedError() } static setAccessRights (e, r, o) { throw new t.NotSupportedError() } static setCustomProperty (e, r, o) { throw new t.NotSupportedError() } static tag (e, r, o) { throw new t.NotSupportedError() } static tagGlobally (e, r, o) { throw new t.NotSupportedError() } static toStringRepresentation (e) { throw new t.NotSupportedError() } static toUri (e) { throw new t.NotSupportedError() } static untag (e, r) { throw new t.NotSupportedError() } static untagGlobally (e, r) { throw new t.NotSupportedError() } static warn (e, r) { throw new t.NotSupportedError() }}t.Server = e, w.Server = e }(Ar || (Ar = {}))), (function (t) { const e = h.default; let r; class o {static appendToPath (e, r) { throw new t.NotSupportedError() } static compareVersionNumber (e, r) { throw new t.NotSupportedError() } static createTempFile (e) { throw new t.NotSupportedError() } static customEventUrl (e, r) { throw new t.NotSupportedError() } static customEventUrlforServer (e, r, o, n) { throw new t.NotSupportedError() } static debug (e) { t.logger.debug(e) } static decimalToHex (e) { throw new t.NotSupportedError() } static error (e) { t.logger.error(e) } static extractDirectory (e) { throw new t.NotSupportedError() } static extractFileName (e) { throw new t.NotSupportedError() } static extractFileNameExtension (e) { throw new t.NotSupportedError() } static extractFileNameWithoutExtension (e) { throw new t.NotSupportedError() } static filterAuthorized (e) { throw new t.NotSupportedError() } static formatBinaryValue (e) { throw new t.NotSupportedError() } static formatDate (e, r) { throw new t.NotSupportedError() } static formatDuration (e, r, o) { throw new t.NotSupportedError() } static formatNumber (e, r) { throw new t.NotSupportedError() } static getAllModules () { return t.modules.getAllModules() } static getContext () { return r || (r = new t.ExecutionContext()) } static getCurrentTime () { return (new Date()).getTime() } static getDate (e, r) { throw new t.NotSupportedError() } static getDateFromFormat (e, r) { throw new t.NotSupportedError() } static getModule (e) { return t.modules.getModule(e) } static getObjectClassName (e) { throw new t.NotSupportedError() } static getObjectId (e) { throw new t.NotSupportedError() } static getObjectPluginName (e) { throw new t.NotSupportedError() } static getObjectType (e) { throw new t.NotSupportedError() } static getOsName () { throw new t.NotSupportedError() } static getTempDirectory () { throw new t.NotSupportedError() } static hexToDecimal (e) { throw new t.NotSupportedError() } static isHostReachable (e, r) { throw new t.NotSupportedError() } static isNotFound (e) { throw new t.NotSupportedError() } static log (e) { t.logger.info(e) } static nextUUID () { const t = e.randomBytes(16).toString('hex'); return `${t.substring(0, 8)}-${t.substring(8, 12)}-${t.substring(12, 16)}-${t.substring(16, 20)}-${t.substring(20)}` } static resolveHostName (e) { throw new t.NotSupportedError() } static resolveIpAddress (e) { throw new t.NotSupportedError() } static sendCustomEvent (e) { throw new t.NotSupportedError() } static setLogMarker (e) { throw new t.NotSupportedError() } static sleep (t) { return this.waitUntil(new Date(Date.now() + t), 0) } static stdout (e) { t.logger.stdout(e) } static waitCustomEventUntil (e, r) { throw new t.NotSupportedError() } static waitUntil (t, e) { return !0 } static warn (e) { t.logger.warn(e) }}t.System = o, w.System = o }(Ar || (Ar = {}))), (function (t) { class e {hasTag (e, r) { throw new t.NotSupportedError() }hasGlobalTag (e, r) { throw new t.NotSupportedError() }}t.TagQuery = e, w.TagQuery = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.executions = [] }cancel () { throw new t.NotSupportedError() }suspend () { throw new t.NotSupportedError() }resume () { throw new t.NotSupportedError() }addParameter (e, r) { throw new t.NotSupportedError() }}t.Task = e, w.Task = e }(Ar || (Ar = {}))), (function (t) { class e {}t.Trigger = e, w.Trigger = e }(Ar || (Ar = {}))), (function (t) { class e {addParameter (e, r) { throw new t.NotSupportedError() }addPath (e) { throw new t.NotSupportedError() }getContent () { throw new t.NotSupportedError() }postContent (e) { throw new t.NotSupportedError() }post () { throw new t.NotSupportedError() }getHostnameOrIPPatternStr () { throw new t.NotSupportedError() }tnamePatternStr () { throw new t.NotSupportedError() }getIPAddressPatternStr () { throw new t.NotSupportedError() }getIPv4AddressPatternStr () { throw new t.NotSupportedError() }getIPv6AddressPatternStr () { throw new t.NotSupportedError() }isValidHostname (e) { throw new t.NotSupportedError() }isValidHostnameOrIPAddress (e) { throw new t.NotSupportedError() }isValidIPAddress (e) { throw new t.NotSupportedError() }isValidIPv4Address (e) { throw new t.NotSupportedError() }isValidIPv6Address (e) { throw new t.NotSupportedError() }escapeHost (e) { throw new t.NotSupportedError() }unescapeHost (e) { throw new t.NotSupportedError() }}t.URL = e, w.URL = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.date = '' }}t.VersionHistoryItem = e, w.VersionHistoryItem = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.firstItem = '', this.items = [], this.inParameters = [], this.outParameters = [], this.attributes = [], this.versionHistoryItems = [], this.executions = [], this.logEvents = [] }saveSchemaImageToFile (e) { throw new t.NotSupportedError() }execute (e, r, o) { throw new t.NotSupportedError() }scheduleRecurrently (e, r, o, n, i, c, s) { throw new t.NotSupportedError() }schedule (e, r, o, n) { throw new t.NotSupportedError() }getExecutionUrl (e, r, o, n, i) { throw new t.NotSupportedError() }getWebviewExecutionUrl (e, r, o, n, i, c, s) { throw new t.NotSupportedError() }getScheduleUrl (e, r, o, n, i) { throw new t.NotSupportedError() }getWebviewScheduleUrl (e, r, o, n, i, c, s) { throw new t.NotSupportedError() }}t.Workflow = e, w.Workflow = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.workflows = [], this.allWorkflows = [], this.subCategories = [] }}t.WorkflowCategory = e, w.WorkflowCategory = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowCustomConditionItem = e, w.WorkflowCustomConditionItem = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowGenericConditionItem = e, w.WorkflowGenericConditionItem = e }(Ar || (Ar = {}))), (function (t) { class e {getAnswerUrl (e, r, o, n, i) { throw new t.NotSupportedError() }getInteractionUrl (e, r, o) { throw new t.NotSupportedError() }getWebviewAnswerUrl (e, r, o, n, i, c, s) { throw new t.NotSupportedError() }}t.WorkflowInput = e, w.WorkflowInput = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowInputItem = e, w.WorkflowInputItem = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowItem = e, w.WorkflowItem = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowItemEnd = e, w.WorkflowItemEnd = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowItemWaitingEvent = e, w.WorkflowItemWaitingEvent = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowItemWaitingTimer = e, w.WorkflowItemWaitingTimer = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowLinkItem = e, w.WorkflowLinkItem = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.linkedWorkflows = [] }}t.WorkflowMultipleCallItem = e, w.WorkflowMultipleCallItem = e }(Ar || (Ar = {}))), (function (t) { class e {}t.WorkflowTaskItem = e, w.WorkflowTaskItem = e }(Ar || (Ar = {}))), (function (t) { class e {constructor () { this.logEvents = [], this.attributesStack = [] }saveSchemaImageToFile (e) { throw new t.NotSupportedError() }cancel () { throw new t.NotSupportedError() }getAnswerUrl (e, r, o, n, i) { throw new t.NotSupportedError() }getInteractionUrl (e, r, o) { throw new t.NotSupportedError() }getWebviewAnswerUrl (e, r, o, n, i, c, s) { throw new t.NotSupportedError() }getInputParameters () { throw new t.NotSupportedError() }getOutputParameters () { throw new t.NotSupportedError() }getAttributes () { throw new t.NotSupportedError() }changeCredential (e) { throw new t.NotSupportedError() }}t.WorkflowToken = e, w.WorkflowToken = e }(Ar || (Ar = {}))), (function (t) { class e {addContent (e, r, o) { throw new t.NotSupportedError() }writeZip () { throw new t.NotSupportedError() }addMimeAttachment (e) { throw new t.NotSupportedError() }clean () { throw new t.NotSupportedError() }}t.ZipWriter = e, w.ZipWriter = e }(Ar || (Ar = {}))), module.exports = {}
